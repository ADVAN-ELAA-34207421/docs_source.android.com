# Bring Up #

Once your code is built and you have verified that all necessary directories exist, power on and test your device with basic bring up, as described below. Bring up tests are typically designed to stress certain aspects of your system and allow you to characterize the device's behavior.

# Confirm a Clean Installation of a Basic Linux Kernel #

Before considering Android-specific modifications to the Linux kernel, verify that you can build, deploy, and boot a core Linux kernel on your target hardware.

# Modify Your Kernel Configuration to Accommodate Android Drivers #

Your kernel configuration file should include the following:

    #
    # Android
    #
    # CONFIG_ANDROID_GADGET is not set
    # CONFIG_ANDROID_RAM_CONSOLE is not set
    CONFIG_ANDROID_POWER=y
    CONFIG_ANDROID_POWER_STAT=y
    CONFIG_ANDROID_LOGGER=y
    # CONFIG_ANDROID_TIMED_GPIO is not set
    CONFIG_ANDROID_BINDER_IPC=y

# Write Drivers #

Android ships with default drivers for all basic functionality but you'll likely want to write your own drivers (or at least customize the default drivers) for your own device depending on your hardware configuration. See the following topics for examples of how to write your own drivers. 

- [Audio](audio_subsystem.html)
- [Keymaps and Keyboard](keymaps_keyboard_input.html)
- [Display](display_drivers.html)

# Burn Images to Flash #

An image represents the state of a system or part of a system  stored in non-volatile memory. The build process should produce the following system images:

- *bootloader*: The bootloader is a small program responsible for initiating loading of the operating system. 
- *boot*:
- *recovery*: 
- *system*: The system image stores a snapshot of the Android operating system.
- *data*: The data image stores user data. Anything not saved to the <code>device/data</code> directory will be lost on reboot.
- *kernel*: The kernel represents the most basic element of an operating system. Android's Linux kernel is responsible for managing the system's resources and acts as an abstraction layer between hardware and a system's applications. 
- *ramdisk*: RAMdisk defines a portion of Random Access Memory (RAM) that gets used as if it were a hard drive. 

Configure the bootloader to load the kernel and RAMdisk into RAM and pass the RAMdisk address to the kernel on 	startup.

# Boot the kernel and mount the RAMdisk. #

# Debug Android-specific init programs on RAMdisk #

Android-specific init programs are found in <code>device/system/init</code>. Add LOG messages to help you debug potential problems with the LOG macro defined in <code>device/system/init/init.c</code>.

The init program directly mounts all filesystems and devices using either hard-coded file names or device names generated by probing the sysfs filesystem (thereby eliminating the need for a <code>/etc/fstab</code> file in Android).  After <code>device/system</code> files are mounted, init  reads <code>/etc/init.rc</code> and invokes the programs listed there (one of the first of which is the console shell).

# Verify that applications have started #

Once the shell becomes available, execute <code>% ps</code> to confirm that the following applications are running:

- <code>/system/bin/logd</code>
- <code>/sbin/adbd</code>
- <code>/system/bin/usbd</code>
- <code>/system/bin/debuggerd</code>
- <code>/system/bin/rild</code>
- <code>/system/bin/app_process</code>
- <code>/system/bin/runtime</code>
- <code>/system/bin/dbus-daemon</code>
- <code>system_server</code>

Each of these applications is embedded Linux C/C++ and you can use any standard Linux debugging tool to troubleshoot applications that aren't running. Execute <code>% make showcommands</code> to determine precise build commands. <code>gdbserver</code> (the GNU debugger) is available in the <code>bin</code> directory of the system partition (please see <a href="http://sourceware.org/gdb/">http://sourceware.org/gdb/</a> for more information). 

# Pulling it all together #

If bring up was successful, you should see the following Java applications (with icons) visible on the LCD panel:

- com.google.android.phone: The Android contact application.
- com.google.android.home
- android.process.google.content

If they are not visible or unresponsive to keypad control, run the <code>framebuffer/keypad</code> tests.

<a name="androidInitLanguage"></a><h1>Android Init Language</h1>

The Android Init Language consists of four broad classes of statements:

- Action
- Commands
- Services
- Options

The language syntax includes the following conventions: 

- All classes are line-oriented and consist of tokens separated by whitespace. c-style backslash escapes may be used to insert whitespace into a token. Double quotes may also be used to prevent whitespace from breaking text into multiple tokens. A backslash appearing as the last character on a line is used for line-folding.
- Lines that start with a \# (leading whitespace allowed) are comments.
- Actions and Services implicitly declare new sections. All commands or options belong to the section most recently declared. Commands or options before the first section are ignored.
- Actions and Services have unique names. If a second Action or Service is declared with the same name as an existing one, it is ignored as an error.

## Actions ##

Actions are named sequences of commands. Actions have a trigger used to determine when the action should occur. When an event occurs which matches an action's trigger, that action is added to the tail of a to-be-executed queue (unless it is already on the queue).

Each action in the queue is dequeued in sequence. Each command in an action is executed in sequence.&nbsp;Init handles other activities (such as, device creation/destruction, property setting, process restarting) "between" the execution of the commands in activities.

Actions take the form of:

    on <trigger>
      <command>
      <command>
      <command>

## Services ##

Services are programs that init launches and (optionally) restarts when they exit. 

Services take the form of:

    service <name> <pathname> [ <argument> ]*
    <option>
    <option>
    ...

## Options ##

Options are modifiers to services that affect how and when init
runs a service. Options are described in the table below:

Option                      | Description
----------------------------|--------------
<code>disabled</code>       | This service will not automatically start with its class. It must be explicitly started by name.
<code>socket <type> <name> <perm> [ <user> [ <group> ] ]</code> | Create a unix domain socket named <code>/dev/socket/<name></code> and pass its fd to the launched process. Valid <code><type></code> values include <code><dgram></code> and <code><stream></code>. <code>user</code> and <code>group</code> default to 0.
<code>user <username></code>| Change to username before exec'ing this service. Currently defaults to root.
<code>group <groupname> [ <groupname> ]*</code> | Change to groupname before exec'ing this service. &nbsp;Additional&nbsp; groupnames beyond the first, which is required, are used to set additional groups of the process (with <code>setgroups()</code>). Currently defaults to root.
<code>capability [ <capability> ]+</code> | Set linux capability before exec'ing this service</td>
<code>oneshot</code> | Do not restart the service when it exits.
<code>class <name></code> | Specify a class name for the service. All services in a named class must start and stop together. A service is considered of class "default" if one is not specified via the class option.

## Triggers ##

Triggers are strings used to match certain kinds of events that cause an action to occur.

  <table>
    <tr>
      <th scope="col">Trigger</th>
      <th scope="col">Description</th>
    </tr>
    <tr>
      <td><code>boot</code></td>
      <td>This is the first trigger that occurs when init starts (after <code>/init.conf</code> is loaded).</td>
    </tr>
    <tr>
      <td><code>&lt;name&gt;=&lt;value&gt;</code></td>
      <td>Triggers of this form occur when the property <code>&lt;name&gt;</code> is set to the specific value <code>&lt;value&gt;</code>.</td>
    </tr>
    <tr>
      <td><code>device-added-&lt;path&gt;<br />
  device-removed-&lt;path&gt;</code></td>
      <td>Triggers of these forms occur when a device node is added or removed.</td>
    </tr>
    <tr>
      <td><code> service-exited-&lt;name&gt;</code></td>
      <td>Triggers of this form occur when the specified service exits.</td>
    </tr>
  </table>
  <p><br />
  Commands</p>
  <table>
    <tr>
      <th scope="col">Command</th>
      <th scope="col">Description</th>
    </tr>
    <tr>
      <td><code>exec &lt;path&gt; [ &lt;argument&gt; ]*</code></td>
      <td>Fork and execute a program (<code>&lt;path&gt;</code>). This will block until the program completes execution. Try to avoid exec. Unlike the <code>builtin</code> commands, it runs the risk of getting init &quot;stuck&quot;.</td>
    </tr>
    <tr>
      <td><code>export &lt;name&gt; &lt;value&gt;</code></td>
      <td>Set the environment variable <code>&lt;name&gt;</code> equal to <code>&lt;value&gt;</code> in the global environment (which will be inherited by all processes started after this command is executed).</td>
    </tr>
    <tr>
      <td><code>ifup &lt;interface&gt;</code></td>
      <td>Bring the network interface <code>&lt;interface&gt;</code> online.</td>
    </tr>
    <tr>
      <td><code>import &lt;filename&gt;</code></td>
      <td> Parse an init config file, extending the current configuration.</td>
    </tr>
    <tr>
      <td><code>hostname &lt;name&gt;</code></td>
      <td>Set the host name.</td>
    </tr>
    <tr>
      <td><code>class_start &lt;serviceclass&gt;</code></td>
      <td>Start all services of the specified class if they are not already running.</td>
    </tr>
    <tr>
      <td><code>class_stop &lt;serviceclass&gt;</code></td>
      <td>Stop all services of the specified class if they are currently running.</td>
    </tr>
    <tr>
      <td><code>domainname &lt;name&gt;</code></td>
      <td>Set the domain name.</td>
    </tr>
    <tr>
      <td><code>insmod &lt;path&gt;</code></td>
      <td>Install the module at <code>&lt;path&gt;</code>.</td>
    </tr>
    <tr>
      <td><code>mkdir &lt;path&gt;</code></td>
      <td>Make a directory at <code>&lt;path&gt;</code>.</td>
    </tr>
    <tr>
      <td><code>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;mountoption&gt; ]*</code></td>
      <td>Attempt to mount the named device at the directory <code>&lt;dir&gt;</code>         <code>&lt;device&gt;</code>. This may be of the form mtd@name to specify a mtd block device by name.</td>
    </tr>
    <tr>
      <td><code>setkey</code></td>
      <td>- currenlty undefined - </td>
    </tr>
    <tr>
      <td><code>setprop &lt;name&gt; &lt;value&gt;</code></td>
      <td>Set system property <code>&lt;name&gt;</code> to <code>&lt;value&gt;</code>.</td>
    </tr>
    <tr>
      <td><code> setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;</code></td>
      <td>Set the rlimit for a resource.</td>
    </tr>
    <tr>
      <td><code>start &lt;service&gt;</code></td>
      <td>Start a service running if it is not already running.</td>
    </tr>
    <tr>
      <td><code> stop &lt;service&gt;</code></td>
      <td>Stop a service from running if it is currently running.</td>
    </tr>
    <tr>
      <td><code>symlink &lt;target&gt; &lt;path&gt;</code></td>
      <td>Create a symbolic link at <code>&lt;path&gt;</code> with the value <code>&lt;target&gt;</code>.</td>
    </tr>
    <tr>
      <td><code>write &lt;path&gt; &lt;string&gt; [ &lt;string&gt; ]*</code></td>
      <td>Open the file at <code>&lt;path&gt;</code> and write one or more strings to it with write(2).</td>
    </tr>
  </table>
  <p>    Properties</p>
    Init updates some system properties to provide some insight into <br />
    what it's doing:</p>
  <table>
    <tr>
      <th scope="col">Property</th>
      <th scope="col">Description</th>
    </tr>
    <tr>
      <td><code>init.action</code></td>
      <td>Equal to the name of the action currently being executed or &quot;&quot; if none.</td>
    </tr>
    <tr>
      <td><code>init.command</code></td>
      <td>Equal to the command being executed or &quot;&quot; if none.</td>
    </tr>
    <tr>
      <td><code>init.svc.&lt;name&gt;</code></td>
      <td>State of a named service (&quot;stopped&quot;, &quot;running&quot;, or &quot;restarting&quot;).</td>
    </tr>
  </table>

Example init.conf

The following snippet is an incomplete example of the <code>init.conf</code> file, simply meant to give you an idea of what a proper configuration resembles.

    on boot
      export PATH /sbin:/system/sbin:/system/bin
      export LD_LIBRARY_PATH /system/lib

      mkdir /dev
      mkdir /proc
      mkdir /sys

      mount tmpfs tmpfs /dev
      mkdir /dev/pts
      mkdir /dev/socket
      mount devpts devpts /dev/pts
      mount proc proc /proc
      mount sysfs sysfs /sys

      write /proc/cpu/alignment 4

      ifup lo

      hostname localhost
      domainname localhost

      mount yaffs2 mtd@system /system
      mount yaffs2 mtd@userdata /data

      import /system/etc/init.conf

      class_start default

    service adbd /sbin/adbd
      user adb
      group adb

    service usbd /system/bin/usbd -r
      user usbd
      group usbd
      socket usbd 666

    service zygote /system/bin/app_process -Xzygote /system/bin --zygote
      socket zygote 666

    service runtime /system/bin/runtime
      user system
      group system

    on device-added-/dev/compass
      start akmd

    on device-removed-/dev/compass
      stop akmd

    service akmd /sbin/akmd
      disabled
      user akmd
      group akmd

